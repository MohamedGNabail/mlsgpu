/**
 * @file
 *
 * Marching tetrahedra algorithm.
 */

#ifndef MARCHING_H
#define MARCHING_H

#if HAVE_CONFIG_H
# include <config.h>
#endif
#include <CL/cl.hpp>
#include <cstddef>
#include <vector>
#include <boost/function.hpp>
#include <clcpp/clcpp.h>

class TestMarching;

/**
 * Marching tetrahedra algorithm implemented in OpenCL.
 * An instance of this class contains buffers to hold intermediate state,
 * and is specialized for a specific OpenCL context and device. An instance
 * also currently specialized to the dimensions of the sampling grid, although
 * that could easily be changed to allow smaller jobs.
 *
 * At present, it has the following features and limitations:
 *  - The values are supplied by a functor that is called to enqueue work to produce
 *    a single slice as a 2D image. This allows the algorithm to work even if the entire
 *    grid is too large to fit in memory.
 *  - Where a non-finite value is present in the field, all adjacent cells are discarded.
 *    This can lead to boundaries in the surface.
 *  - The output is mostly polygon soup. The common vertices within each cell are
 *    represented only once, but vertices are not shared between cells.
 *
 * The implementation operates on a slice at a time. For each slice, it:
 *  -# Identifies the cells that are not empty (not entirely inside, entirely
 *     outside, or containing non-finite values).
 *  -# Compacts those cells into an array to allow more efficient iteration over them.
 *  -# Extracts the number of vertices and indices each (compacted) cell will produce.
 *  -# Performs of these counts to allocate positions in the array. These scans are
 *     seeded with the total number already produced.
 *  -# Generates the vertices and indices.
 */
class Marching
{
    friend class TestMarching;
private:
    static const unsigned int NUM_CUBES = 256;      ///< Number of possible vertex codes for a cube (2^vertices)
    static const unsigned int NUM_EDGES = 19;       ///< Number of edges in each cube
    static const unsigned int NUM_TETRAHEDRA = 6;   ///< Number of tetrahedra in each cube

    static const unsigned int MAX_CELL_VERTICES = 13; ///< Maximum vertices generated per cell
    static const unsigned int MAX_CELL_INDICES = 36;  ///< Maximum triangles generated per cell

    /**
     * The vertices incident on each edge. It is important that the vertex indices
     * are in order in each edge.
     */
    static const unsigned char edgeIndices[NUM_EDGES][2];

    /**
     * The vertices of each tetrahedron in a cube. The vertices must be wound
     * consistently such that the first three appear counter-clockwise when
     * viewed from the fourth in a right-handed coordinate system.
     */
    static const unsigned char tetrahedronIndices[NUM_TETRAHEDRA][4];

    /**
     * The number of cell corners (not cells) in the grid.
     */
    std::size_t width, height, depth;

    cl::Context context;   ///< OpenCL context used to allocate buffers

    /**
     * Buffer of uchar2 values, indexed by cube code. The two elements are
     * the number of vertices and indices generated by the cell.
     */
    cl::Buffer countTable;
    /**
     * Buffer of ushort2 values, indexed by cube code. The two elements are
     * the positions of the index array and vertex array in @ref dataTable.
     * It has one extra element at the end so that the element range for
     * the last cube code can be found.
     */
    cl::Buffer startTable;
    /**
     * Buffer of uchar values, which are either indices to be emitted
     * (after biasing), or vertices represented as an edge ID. The range
     * of vertices or indices for a particular cube code is determined by
     * two adjacent elements of @ref countTable.
     */
    cl::Buffer dataTable;
    /**
     * Buffer of ulong values, in ranges indexed by startTable. It contains
     * biases to be added to the cell key to get a vertex key for each
     * vertex generated in a cell.
     *
     * A vertex key is a 63-bit value with 3 21-bit fields, each of which is
     * a 20.1 fixed-point representation. The three values (from LSB) give
     * the x, y, z coordinates of the midpoint of the edge generating the
     * vertex (in local coordinates). The cell key is simply the vertex
     * key for the vertex at minimum-x/y/z corner.
     *
     * @todo Make the range dynamic to be more friendly to the radix sort.
     */
    cl::Buffer keyTable;

    /**
     * Buffer of uint2 values, indexed by compacted cell ID. Initially they are
     * the number of vertices and indices generated by each cell;
     * after a scan they are the positions to write the vertex/indices.
     */
    cl::Buffer viCount;

    /**
     * Buffer of uint2 values, indexed by compacted cell ID. They are the 2D
     * coordinates of the corresponding original cell.
     */
    cl::Buffer cells;

    /**
     * Buffer of uint values, indexed by uncompacted cell ID. Initially it is a
     * boolean array of cells that are non-empty, which is then scanned to
     * produce the forward compaction mapping. Uncompacted cell IDs are y-major.
     */
    cl::Buffer occupied;

    /**
     * A buffer of one uint2 value, containing the position to start writing more
     * vertices and indices.
     */
    cl::Buffer offsets;

    /**
     * Intermediate unwelded vertices. These are @c cl_float4 values, with the
     * w component holding a bit-cast of the original index before sorting by key.
     */
    cl::Buffer unweldedVertices;

    /**
     * Sort keys corresponding from @ref unweldedVertices.
     */
    cl::Buffer vertexKeys;

    /**
     * Indicator for whether each unwelded vertex is unique. It is then scanned
     * to produce a remap table for compacting vertices. It also has one extra
     * element at the end to allow the total number of welded vertices to be
     * read back.
     */
    cl::Buffer vertexUnique;

    /**
     * Remapping table used to map unwelded vertex indices to welded vertex
     * indices. It combines the sorting by key with the compaction.
     */
    cl::Buffer indexRemap;

    /**
     * The images holding two slices of the signed distance function.
     */
    cl::Image2D backingImages[2];

    /**
     * Pointers into @ref backingImages, which are swapped to advance to the
     * next slice.
     */
    cl::Image2D *images[2];

    cl::Program program;                    ///< Program compiled from @ref marching.cl.
    cl::Kernel countOccupiedKernel;         ///< Kernel compiled from @ref countOccupied.
    cl::Kernel compactKernel;               ///< Kernel compiled from @ref compact.
    cl::Kernel countElementsKernel;         ///< Kernel compiled from @ref countElements.
    cl::Kernel generateElementsKernel;      ///< Kernel compiled from @ref generateElements.
    cl::Kernel countUniqueVerticesKernel;   ///< Kernel compiled from @ref countUniqueVertices.
    cl::Kernel compactVerticesKernel;       ///< Kernel compiled from @ref compactVerticesKernel.
    cl::Kernel reindexKernel;               ///< Kernel compiled from @ref reindexKernel.

    clcpp::Scan scanUint;                   ///< Scanner to scan @c cl_uint values.
    clcpp::Scan scanElements;               ///< Scanner to scan @ref viCount.
    clcpp::Radixsort sortVertices;          ///< Sorts vertices by keys for welding.

    /**
     * Finds the edge incident on vertices v0 and v1.
     *
     * @pre edge (v0, v1) is one of the existing edges
     */
    static unsigned int findEdgeByVertexIds(unsigned int v0, unsigned int v1);

    /**
     * Determines the parity of a permutation.
     *
     * The permutation can contain any unique values - they do not need to be
     * 0..n-1. It is considered to be the permutation that would map the
     * sorted sequence to the given sequence.
     *
     * @param first, last The range to measure (forward iterators)
     * @retval 0 if the permutation contains an odd number of swaps
     * @retval 1 if the permutation contains an even number of swaps.
     */
    template<typename Iterator>
    static unsigned int permutationParity(Iterator first, Iterator last);

    /**
     * Populate the static tables describing how to slice up cells.
     */
    void makeTables();

public:
    /**
     * The function type to pass to @ref enqueue.
     * An invocation of this function must enqueue commands to generate
     * one slice of the sampling grid to the provided command queue (which
     * is the same one passed to @ref enqueue). The @a z value will range
     * from 0 to one less than the number of cell corners in the Z dimension.
     * The return event must be populated (even for an in-order queue), because
     * the caller will wait for it at the appropriate time.
     *
     * It is guaranteed that even if the queue is out-of-order, the events will
     * be arranged such that the commands enqueued by one call to the functor will
     * happen-before those enqueued by the next call (provided that the functor itself
     * correctly inserts dependencies on the events passed in). It is thus safe
     * for the functor to contain OpenCL scratch buffers that are overwritten during
     * each call.
     *
     * However, it is not guaranteed that the commands enqueued by one call to the
     * functor will complete before the next host call to the functor.
     */
    typedef boost::function<void(const cl::CommandQueue &, const cl::Image2D &, cl_uint z, const std::vector<cl::Event> *, cl::Event *)> Functor;

    /**
     * Constructor. Note that it must be possible to allocate an OpenCL 2D image of
     * dimensions @a width by @a height, so they should be constrained appropriately.
     *
     * Apart from O(1) overheads for tables etc, the total OpenCL memory
     * allocated is:
     *  - 8 * @a width * @a height bytes in images.
     *  - 20 * (@a width - 1) * (@a height - 1) bytes in buffers.
     *
     * @param context        OpenCL context used to allocate buffers.
     * @param device         Device for which kernels are to be compiled.
     * @param width, height, depth Number of cell corners in the sampling grid.
     *
     * @pre @a width, @a height, @a depth are all at least 2.
     */
    Marching(const cl::Context &context, const cl::Device &device,
             std::size_t width, std::size_t height, std::size_t depth);

    /**
     * Enqueue work to generate an isosurface. This command will (optionally)
     * return an event to indicate when the work is complete. It is safe
     * to call this method again only if one ensures that the work from
     * the previous call completes before work from this call (e.g. with a
     * command queue barrier, in-order queue, passing the previous event in
     * as a dependency etc).
     *
     * At present there is no protection against buffer overrun. You are
     * responsible for passing in @a vertices and @a indices
     * that are large enough to hold the result.
     *
     * @see @ref MAX_CELL_VERTICES, @ref MAX_CELL_INDICES.
     *
     * @param queue          Command queue to enqueue the work to.
     * @param functor        Generates slices of the function (see @ref Functor).
     * @param gridScale      Scale from grid coordinates to world coordinates for vertices.
     * @param gridBias       Bias from grid coordinates to world coordinates for vertices.
     * @param[out] vertices  Buffer to write the vertices to. It will contain @c cl_float3 values.
     * @param[out] indices   Buffer to write the indices to. It will contain
     *                       @c cl_uint values indexing @a vertices.
     * @param[out] totals    The number of vertices and indices written to the buffers
     *                       (only valid once the queued work has completed!)
     * @param events         Previous events to wait for (can be @c NULL).
     * @param[out] event     Event that will fire when work is complete (can be @c NULL).
     */
    void enqueue(const cl::CommandQueue &queue, const Functor &functor,
                 const cl_float3 &gridScale, const cl_float3 &gridBias,
                 cl::Buffer &vertices, cl::Buffer &indices,
                 cl_uint2 *totals,
                 const std::vector<cl::Event> *events = NULL,
                 cl::Event *event = NULL);
};

#endif /* !MARCHING_H */
