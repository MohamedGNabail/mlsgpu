/**
 * @file
 *
 * Marching tetrahedra algorithm.
 */

#ifndef MARCHING_H
#define MARCHING_H

#if HAVE_CONFIG_H
# include <config.h>
#endif
#include <CL/cl.hpp>
#include <cstddef>
#include <vector>
#include <boost/function.hpp>
#include <clcpp/clcpp.h>
#include "grid.h"

class TestMarching;

/**
 * Marching tetrahedra algorithm implemented in OpenCL.
 * An instance of this class contains buffers to hold intermediate state,
 * and is specialized for a specific OpenCL context and device. An instance
 * also currently specialized to the dimensions of the sampling grid, although
 * that could easily be changed to allow smaller jobs.
 *
 * At present, it has the following features and limitations:
 *  - The values are supplied by a functor that is called to enqueue work to produce
 *    a single slice as a 2D image. This allows the algorithm to work even if the entire
 *    grid is too large to fit in memory.
 *  - Where a non-finite value is present in the field, all adjacent cells are discarded.
 *    This can lead to boundaries in the surface.
 *  - The output is mostly polygon soup. The common vertices within each cell are
 *    represented only once, but vertices are not shared between cells.
 *
 * The implementation operates on a slice at a time. For each slice, it:
 *  -# Identifies the cells that are not empty (not entirely inside, entirely
 *     outside, or containing non-finite values).
 *  -# Compacts those cells into an array to allow more efficient iteration over them.
 *  -# Extracts the number of vertices and indices each (compacted) cell will produce.
 *  -# Performs of these counts to allocate positions in the array. These scans are
 *     seeded with the total number already produced.
 *  -# Generates the vertices and indices.
 */
class Marching
{
    friend class TestMarching;
private:
    static const unsigned int NUM_CUBES = 256;      ///< Number of possible vertex codes for a cube (2^vertices)
    static const unsigned int NUM_EDGES = 19;       ///< Number of edges in each cube
    static const unsigned int NUM_TETRAHEDRA = 6;   ///< Number of tetrahedra in each cube

    static const unsigned int MAX_CELL_VERTICES = 13; ///< Maximum vertices generated per cell
    static const unsigned int MAX_CELL_INDICES = 36;  ///< Maximum triangles generated per cell

    /**
     * The vertices incident on each edge. It is important that the vertex indices
     * are in order in each edge.
     */
    static const unsigned char edgeIndices[NUM_EDGES][2];

    /**
     * The vertices of each tetrahedron in a cube. The vertices must be wound
     * consistently such that the first three appear counter-clockwise when
     * viewed from the fourth in a right-handed coordinate system.
     */
    static const unsigned char tetrahedronIndices[NUM_TETRAHEDRA][4];

    /**
     * The number of cell corners (not cells) in the grid.
     */
    std::size_t maxWidth, maxHeight;

    /**
     * Space allocated to hold intermediate vertices and indices.
     *
     * @todo Make these tunable.
     */
    std::size_t vertexSpace, indexSpace;

    cl::Context context;   ///< OpenCL context used to allocate buffers

    /**
     * Buffer of uchar2 values, indexed by cube code. The two elements are
     * the number of vertices and indices generated by the cell.
     */
    cl::Buffer countTable;
    /**
     * Buffer of ushort2 values, indexed by cube code. The two elements are
     * the positions of the index array and vertex array in @ref dataTable.
     * It has one extra element at the end so that the element range for
     * the last cube code can be found.
     */
    cl::Buffer startTable;
    /**
     * Buffer of uchar values, which are either indices to be emitted
     * (after biasing), or vertices represented as an edge ID. The range
     * of vertices or indices for a particular cube code is determined by
     * two adjacent elements of @ref countTable.
     */
    cl::Buffer dataTable;
    /**
     * Buffer of ulong values, in ranges indexed by startTable. It contains
     * biases to be added to the cell key to get a vertex key for each
     * vertex generated in a cell.
     *
     * A vertex key is a 63-bit value with 3 21-bit fields, each of which is
     * a 20.1 fixed-point representation. The three values (from LSB) give
     * the x, y, z coordinates of the midpoint of the edge generating the
     * vertex (in local coordinates). The cell key is simply the vertex
     * key for the vertex at minimum-x/y/z corner.
     *
     * @todo Make the range dynamic to be more friendly to the radix sort.
     */
    cl::Buffer keyTable;

    /**
     * Buffer of uint2 values, indexed by compacted cell ID. Initially they are
     * the number of vertices and indices generated by each cell;
     * after a scan they are the positions to write the vertex/indices.
     */
    cl::Buffer viCount;

    /**
     * Buffer of uint2 values, indexed by compacted cell ID. They are the 2D
     * coordinates of the corresponding original cell.
     */
    cl::Buffer cells;

    /**
     * Buffer of uint values, indexed by uncompacted cell ID. Initially it is a
     * boolean array of cells that are non-empty, which is then scanned to
     * produce the forward compaction mapping. Uncompacted cell IDs are y-major.
     */
    cl::Buffer occupied;

    /**
     * Intermediate unwelded vertices. These are @c cl_float4 values, with the
     * w component holding a bit-cast of the original index before sorting by key.
     */
    cl::Buffer unweldedVertices;

    /**
     * Welded vertices. These are tightly packed @c float3 values.
     */
    cl::Buffer vertices;

    /**
     * Indices. Before welding, these are local (0-based) and index the @ref unweldedVertices
     * array. During welding, these are rewritten to refer to welded vertices, and are
     * offset by the number of vertices previously shipped out so that they index the
     * virtual array of all emitted vertices.
     */
    cl::Buffer indices;

    /**
     * Sort keys corresponding from @ref unweldedVertices.
     */
    cl::Buffer vertexKeys;

    /**
     * Indicator for whether each unwelded vertex is unique. It is then scanned
     * to produce a remap table for compacting vertices. It also has one extra
     * element at the end to allow the total number of welded vertices to be
     * read back.
     */
    cl::Buffer vertexUnique;

    /**
     * Remapping table used to map unwelded vertex indices to welded vertex
     * indices. It combines the sorting by key with the compaction.
     */
    cl::Buffer indexRemap;

    /**
     * The images holding two slices of the signed distance function.
     */
    cl::Image2D backingImages[2];

    cl::Program program;                    ///< Program compiled from @ref marching.cl.
    cl::Kernel countOccupiedKernel;         ///< Kernel compiled from @ref countOccupied.
    cl::Kernel compactKernel;               ///< Kernel compiled from @ref compact.
    cl::Kernel countElementsKernel;         ///< Kernel compiled from @ref countElements.
    cl::Kernel generateElementsKernel;      ///< Kernel compiled from @ref generateElements.
    cl::Kernel countUniqueVerticesKernel;   ///< Kernel compiled from @ref countUniqueVertices.
    cl::Kernel compactVerticesKernel;       ///< Kernel compiled from @ref compactVerticesKernel.
    cl::Kernel reindexKernel;               ///< Kernel compiled from @ref reindexKernel.

    clcpp::Scan scanUint;                   ///< Scanner to scan @c cl_uint values.
    clcpp::Scan scanElements;               ///< Scanner to scan @ref viCount.
    clcpp::Radixsort sortVertices;          ///< Sorts vertices by keys for welding.

    /**
     * Finds the edge incident on vertices v0 and v1.
     *
     * @pre edge (v0, v1) is one of the existing edges
     */
    static unsigned int findEdgeByVertexIds(unsigned int v0, unsigned int v1);

    /**
     * Determines the parity of a permutation.
     *
     * The permutation can contain any unique values - they do not need to be
     * 0..n-1. It is considered to be the permutation that would map the
     * sorted sequence to the given sequence.
     *
     * @param first, last The range to measure (forward iterators)
     * @retval 0 if the permutation contains an odd number of swaps
     * @retval 1 if the permutation contains an even number of swaps.
     */
    template<typename Iterator>
    static unsigned int permutationParity(Iterator first, Iterator last);

    /**
     * Populate the static tables describing how to slice up cells.
     */
    void makeTables();

public:
    /**
     * The function type to pass to @ref generate for sampling the isofunction.
     * An invocation of this function must enqueue commands to generate
     * one slice of the sampling grid to the provided command queue (which
     * is the same one passed to @ref generate). The @a z value will range
     * from 0 to one less than the number of cell corners in the Z dimension.
     * The return event must be populated (even for an in-order queue), because
     * the caller will wait for it at the appropriate time.
     *
     * It is guaranteed that even if the queue is out-of-order, the events will
     * be arranged such that the commands enqueued by one call to the functor will
     * happen-before those enqueued by the next call (provided that the functor itself
     * correctly inserts dependencies on the events passed in). It is thus safe
     * for the functor to contain OpenCL scratch buffers that are overwritten during
     * each call.
     *
     * However, it is not guaranteed that the commands enqueued by one call to the
     * functor will complete before the next host call to the functor.
     */
    typedef boost::function<void(const cl::CommandQueue &, const cl::Image2D &, cl_uint z, const std::vector<cl::Event> *, cl::Event *)> InputFunctor;

    /**
     * The function type to pass to @ref generate for receiving output data.
     * When invoked, this function must enqueue commands to retrieve the data
     * from the supplied buffers. It must return an event that will be signaled
     * when it is safe for the caller to overwrite the supplied buffers (if it
     * operates synchronously, it should just return an already-signaled user
     * event).
     *
     * Calls to this function are serialized, but the work that it enqueues may
     * proceed in parallel.
     *
     * The command-queue is provided for convenience. If the event returned is
     * not associated with the same command-queue, the callee is responsible for
     * ensuring that the work completes within finite time.
     *
     * The vertices and indices returned will correspond, but the indices will
     * be suitably offset so that they index the concatenation of all the vertices
     * passed to the callback. The vertices are in tightly packed cl_float triplets
     * (x,y,z) while the indices are in tightly packed cl_uint index triplets.
     */
    typedef boost::function<void(const cl::CommandQueue &,
                                 const cl::Buffer &vertices,
                                 const cl::Buffer &indices,
                                 std::size_t numVertices,
                                 std::size_t numIndices,
                                 cl::Event *event)> OutputFunctor;

    /**
     * Constructor. Note that it must be possible to allocate an OpenCL 2D image of
     * dimensions @a width by @a height, so they should be constrained appropriately.
     *
     * Apart from O(1) overheads for tables etc, the total OpenCL memory
     * allocated is:
     *  - 8 * @a width * @a height bytes in images.
     *  - 20 * (@a width - 1) * (@a height - 1) bytes in buffers.
     *
     * @param context        OpenCL context used to allocate buffers.
     * @param device         Device for which kernels are to be compiled.
     * @param maxWidth, maxHeight Maximum X, Y dimensions of the provided sampling grid.
     *
     * @pre @a maxWidth and @a maxHeight are all at least 2.
     */
    Marching(const cl::Context &context, const cl::Device &device,
             std::size_t maxWidth, std::size_t maxHeight);

    /**
     * Generate an isosurface.
     *
     * @note Because this function needs to read back intermediate results
     * before enqueuing more work, this is not purely an enqueuing operation.
     * It will block until somethe work has completed. To hide latency, it is
     * necessary to have something happening on another CPU thread.
     *
     * @param queue          Command queue to enqueue the work to.
     * @param input          Generates slices of the function (see @ref InputFunctor).
     * @param output         Functor to receive chunks of output (see @ref OutputFunctor).
     * @param grid           Sampling grid.
     * @param indexOffset    Bias to add to all indices.
     * @param events         Previous events to wait for (can be @c NULL).
     *
     * @pre The number of vertices in @a grid must not exceed the dimensions
     * passed to the constructor.
     */
    void generate(const cl::CommandQueue &queue,
                  const InputFunctor &input,
                  const OutputFunctor &output,
                  const Grid &grid,
                  std::size_t indexOffset,
                  const std::vector<cl::Event> *events = NULL);

private:
    /**
     * Determine which cells in a slice need to be processed further.
     * This function may wait for previous events, but operates
     * synchronously. On input, two images contain adjacent slices of
     * samples of the function. On output, @ref cells contains a list
     * of x,y pairs giving the coordinates of the cells that will generate
     * geometry, and @ref occupied has been clobbered.
     *
     * @param queue           Command queue to use for enqueuing work.
     * @param sliceA,sliceB   Images containing isofunction values.
     * @param width,height    Dimensions of the image portions that are populated.
     * @param events          Events to wait for before starting (may be @c NULL).
     *
     * @return The number of cells that need further processing.
     *
     * @todo It need not be totally synchronous (compaction is independent).
     */
    std::size_t generateCells(const cl::CommandQueue &queue,
                              const cl::Image2D &sliceA,
                              const cl::Image2D &sliceB,
                              std::size_t width, std::size_t height,
                              const std::vector<cl::Event> *events);

    /**
     * Count the number of vertices and indices that will be generated
     * by each (compacted) cell. This function may wait for previous work,
     * but does its own work synchronously and so does not return an event.
     * On output, @ref viCount contains pairs of offsets into the vertex
     * and index outputs that indicate where each cell should emit its
     * geometry.
     *
     * @param queue           Command queue to use for enqueuing work.
     * @param sliceA,sliceB   Images containing isofunction values.
     * @param compacted       Number of cells in @ref cells.
     * @param events          Events to wait for before starting (may be @c NULL).
     * @return The total number of vertices and indices that will be generated.
     */
    cl_uint2 countElements(const cl::CommandQueue &queue,
                           const cl::Image2D &sliceA,
                           const cl::Image2D &sliceB,
                           std::size_t compacted,
                           const std::vector<cl::Event> *events);

    /**
     * Post-process a batch of geometry and send it to the output functor.
     * This function operates asynchronously, with an event returned to
     * indicate completion. It handles welding of shared vertices into
     * a single vertex and the corresponding reindexing, as well as
     * offsetting indices to be relative to the global set of vertices.
     *
     * The input vertices are in @ref unweldedVertices and @ref indices.
     * The welded vertices are placed in @ref vertices, and the indices
     * are updated in-place. As a side effect, @ref vertexUnique and
     * @ref indexRemap are clobbered.
     *
     * @param queue           Command queue to use for enqueuing work.
     * @param indexOffset     Value added to all indices.
     * @param sizes           Number of vertices and indices in input.
     * @param output          Functor to which the welded geometry is passed.
     * @param events          Events to wait for before starting (may be @c NULL).
     * @param event           Event to wait for before returning (may be @c NULL).
     */
    std::size_t shipOut(const cl::CommandQueue &queue,
                        std::size_t indexOffset,
                        const cl_uint2 &sizes,
                        const OutputFunctor &output,
                        const std::vector<cl::Event> *events,
                        cl::Event *event);
};

#endif /* !MARCHING_H */
