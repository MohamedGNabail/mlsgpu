<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd">
<book>
    <title>MLSGPU User Manual</title>
    <bookinfo>
        <author>
            <firstname>Bruce</firstname><surname>Merry</surname>
            <email>bmerry@cs.uct.ac.za</email>
        </author>
        <copyright>
            <year>2012</year>
            <holder>University of Cape Town</holder>
        </copyright>
        <!-- Stylesheet replaces this empty element with a version number -->
        <releaseinfo>
        </releaseinfo>
    </bookinfo>
    <chapter id="installation">
        <title>Installation</title>
        <section id="installation.dependencies">
            <title>Dependencies</title>
            <para>
                MLSGPU requires a POSIX operating system such as a GNU/Linux
                system. At present only Ubuntu 11.10 has been tested, but other
                variants are expected to work. It is also highly recommended
                that you use a 64-bit operating system, as otherwise you will
                be limited to around 2GB of input data.
            </para>
            <para>
                MLSGPU dependends on the following software to compile and run.
                Versions listed are the ones that have been tested; older
                or newer versions will often work too.
            </para>
            <itemizedlist>
                <listitem><para>A C++ compiler. GCC 4.4 and 4.6, and clang 2.9
                        have been tested.</para></listitem>
                <listitem><para><ulink
                            href="http://www.boost.org/">Boost</ulink> 1.46,
                        including the following runtime libraries:</para>
                    <itemizedlist>
                        <listitem><para><systemitem
                                    class="library">boost_program_options</systemitem></para></listitem>
                        <listitem><para><systemitem
                                    class="library">boost_iostreams</systemitem></para></listitem>
                        <listitem><para><systemitem
                                    class="library">boost_thread</systemitem></para></listitem>
                        <listitem><para><systemitem
                                    class="library">boost_math_c99</systemitem></para></listitem>
                        <listitem><para><systemitem
                                    class="library">boost_math_c99f</systemitem></para></listitem>
                    </itemizedlist>
                </listitem>
                <listitem><para><ulink
                            href="http://stxxl.sourceforge.net/">STXXL</ulink> 1.3.1</para></listitem>
                <listitem><para><ulink
                            href="http://clogs.sourceforge.net/">clogs</ulink> 1.0.2</para></listitem>
                <listitem><para><ulink
                            href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</ulink> 1.7.4</para></listitem>
                <listitem><para><ulink
                            href="http://www.python.org">Python</ulink> 2.7</para></listitem>
                <listitem><para><ulink
                            href="http://xmlsoft.org/xslt/">xsltproc</ulink> 1.1</para></listitem>
                <listitem><para><ulink
                            href="http://docbook.sf.net/">DocBook</ulink> 4.3 stylesheets</para></listitem>
                <listitem><para>An implementation of OpenCL 1.1. GPU device
                        drivers will normally include this. It has been tested
                        with NVIDIA GPU drivers and with the AMD APP SDK 2.6
                        on a CPU. The device must support images.</para></listitem>
            </itemizedlist>
            <para>
                The following tools and libraries are necessarily to build
                optional parts, but are not required:
            </para>
            <itemizedlist>
                <listitem><para><ulink
                            href="http://sourceforge.net/apps/mediawiki/cppunit/">CppUnit</ulink>
                        1.12 is needed to build the test
                        suite.</para></listitem>
            </itemizedlist>
            <para>
                The following list of packages should suffice on Ubuntu 11.10 (although it has
                not been tested against a clean installation), with the
                exception of <systemitem class="library">clogs</systemitem> which has not been
                packaged for Ubuntu.
            </para>
            <screen>xsltproc
docbook-xml
docbook-xsl
libboost-dev
libboost-iostreams-dev
libboost-math-dev
libboost-program-options-dev
libboost-thread-dev
libcppunit-dev
libstxxl-dev
g++-4.6
python2.7</screen>
        </section>
        <section id="installation.compiling">
            <title>Compiling</title>
            <para>
                Before actually compiling, the build must be configured. This can be
                done by running <userinput>./waf configure</userinput>. This
                will check that the required libraries are present. If
                configuration fails, you can find more detailed error
                information in <filename>build/config.log</filename>. The
                build system will attempt to auto-detect the compiler, but if
                you wish to override it you can set the <envar>CXX</envar>
                environment variable before doing the configuration.
            </para>
            <para>
                There are also
                some command-line options that can be given to affect the
                configured build. They are intended mainly for developer
                rather than end-user use, so they are not documented here.
                Running <userinput>./waf configure --help</userinput> will
                show a full list.
            </para>
            <para>
                Once configuration is complete, running
                <userinput>./waf</userinput> will perform the compilation.
            </para>
        </section>
        <section id="installation.stxxl">
            <title>Configuring STXXL</title>
            <para>
                STXXL is a library that manages large data sets by using
                temporary storage on disk. Although it can be used without
                configuration for small runs, its default configuration will
                not provide enough storage for large data sets.
            </para>
            <para>
                See the <ulink
                    href="http://algo2.iti.kit.edu/stxxl/tags/1.3.1/installation_linux_gcc.html">STXXL
                    documentation</ulink> for instructions on configuring
                STXXL's on-disk storage. As a rule of thumb, you will need
                to reserve a minimum of 60 bytes per output vertex, and having
                slightly more is safer. Note that this applies to all output
                vertices from a single run, even if they are split across
                multiple output files. If you do not have this much temporary
                space available, see TODO for an alternative mode which takes
                longer but uses far less temporary storage.
            </para>
        </section>
        <section id="installation.install">
            <title>Installing</title>
            <para>
                TODO: build system doesn't currently handle <userinput>./waf
                    install</userinput> well at all.
            </para>
        </section>
    </chapter>
    <chapter id="running">
        <title>Running MLSGPU</title>
        <section id="running.input">
            <title>Input files</title>
            <para>
                The input format for MLSGPU is the PLY file format.
                Additionally, it is restricted to a subset of valid PLY files:
            </para>
            <itemizedlist>
                <listitem><para>Only binary files are supported, and only in
                        the endianness used by the host CPU (typically
                        little-endian for an x86 or x86-64
                        CPU).</para></listitem>
                <listitem><para>The first type of element in the file must be
                        <literal>vertex</literal>. Other elements may be
                        present but they must occur later in the file, and
                        will be ignored.</para></listitem>
                <listitem><para>The <literal>vertex</literal> element must
                        contain the fields
                        <literal>x</literal>,
                        <literal>y</literal>,
                        <literal>z</literal>,
                        <literal>nx</literal>,
                        <literal>ny</literal>,
                        <literal>nz</literal>
                        and <literal>radius</literal> (explained below), and
                        they must all have type <symbol>float32</symbol>.
                        Other fields may be present as long as they are not
                        lists, and they will be ignored.</para></listitem>
            </itemizedlist>
            <para>
                The positions are given by <literal>x</literal>,
                <literal>y</literal> and <literal>z</literal>. The units are
                arbitrarily, but they must of course match across all input
                files. The oriented normals are given by
                <literal>nx</literal>, <literal>ny</literal> and
                <literal>nz</literal>, and they must have unit length. The
                final required field is <literal>radius</literal>, which is an
                estimate of the spacing between the sample and its neighbors.
                This must be positive and use the same units as the position.
            </para>
            <para>
                For best performance, the order of input samples in a file
                should correlate will with position. Simply outputting the
                points they are encountered in a regular sampling grid will
                give good results. In particular, do not sort the points along
                a single axis, as this will reduce coherence.
            </para>
            <para>
                MLSGPU accepts multiple input files. The files must already
                have been registered and transformed into a common coordinate
                system.  While MLSGPU itself imposes an upper bound on the
                number of input files that can be used, in practise it is
                operating system limits on the number of open files that are
                likely to be the real limitation. On Ubuntu (and probably most
                other GNU/Linux systems) the limit on the number of open files
                can be increased once-off using <command>ulimit</command> or
                for all users by editing
                <filename>/etc/security/limits.conf</filename>.
            </para>
        </section>
        <section id="running.output">
            <title>Output files</title>
            <para>
                The output format for MLSGPU is again the PLY file format. The
                output file will contain just vertex positions and triangles;
                all other metadata from the input is discarded. MLSGPU can
                either write the entire output mesh to a single PLY file, or
                break the bounding box up into a regular grid and output a
                separate PLY file for each non-empty grid cell. In the latter
                case, the vertices at the boundaries between files will be
                duplicated in both files, so that neighboring files can be
                loaded together to give a seamless join.
            </para>
        </section>
        <section id="running.commandline">
            <title>Command-line options</title>
            <para>
                The minimum command-line for running MLSGPU is
            </para>
            <cmdsynopsis>
                <command>mlsgpu</command>
                <arg choice="plain">--fit-grid=<replaceable>spacing</replaceable></arg>
                <arg choice="plain">-o <replaceable>output.ply</replaceable></arg>
                <arg choice="plain" rep="repeat"><replaceable>input.ply</replaceable></arg>
            </cmdsynopsis>
            <para>
                The <replaceable>spacing</replaceable> specifies the spacing
                between sample points in a regular grid that will be used in
                the Marching Tetrahedra algorithm. All vertices in the output
                file will be on edges of this grid. This value should be of a
                similar order of magnitude to the finest scanning density.
                Using too large a value will not only cause the reconstruction
                to look blocky, but will also lead to unexpected holes. Using
                too small a value will lead to an excessively large output
                file, and will also significantly increase the running time.
            </para>
            <para>
                Operating systems sometimes place a limit on the length of a
                command-line, which can be difficult if there are a very large
                number of input files. To work around this, a
                <firstterm>response file</firstterm> can be used to place the
                command-line arguments in a file. First create a file with the
                command-line arguments. The arguments can be separated by
                whitespace or placed on separate lines. Then pass
                <option>--response-file
                    <replaceable>filename</replaceable></option> when running
                MLSGPU. It is possible to place some arguments in the response
                file and others on the command line, but only one response
                file is supported. The response-file processor is also extremely
                basic: spaces in filenames will cause problems, and shell
                wildcards will not work.
            </para>
            <para>
                The following subsections document the options that are
                intended for general use. There are additional options that
                are only intended for use by the developers of MLSGPU, and
                which are not documented. You can see a full list of options
                by running <userinput><command>mlsgpu</command>
                    <option>--help</option></userinput>, which also shows the
                default values used.
            </para>
            <section id="running.commandline.split">
                <title>Splitting the output</title>
                <para>
                    Rather than producing a single giant output file, it is
                    possible to split the output into chunks by passing
                    <option>--split</option> on the command line. The chunks form
                    a regular grid and each chunk is named
                    <filename><replaceable>basename</replaceable>_<replaceable>XXXX</replaceable>_<replaceable>YYYY</replaceable>_<replaceable>ZZZZ</replaceable>.ply</filename>,
                    where <replaceable>XXXX</replaceable>, <replaceable>YYYY</replaceable> and
                    <replaceable>ZZZZ</replaceable> are the positions within
                    this grid and <replaceable>basename</replaceable> is the
                    argument to <option>-o</option>. Note that for this usage,
                    the argument to <option>-o</option> should be just a
                    prefix and not a full filename.
                </para>
                <para>
                    Only output files that contain at least one triangle are
                    written. If you are experimenting with different
                    parameters, it is strongly recommended that you delete all
                    the outputs from previous runs with the same basename
                    before starting, as if the corresponding file is not
                    written in the current run then the old file will be mixed
                    in with the other newly written files.
                </para>
                <para>
                    The spatial size of the chunks is chosen automatically
                    using heuristics that attempt to keep the size of each
                    file manageable, but since it is impossible to determine
                    the sizes of the output files in advance, the heuristic
                    may need to be adjusted if the output files are too big or
                    too small. This can be done by passing
                    <option>--split-size=<replaceable>size</replaceable></option>,
                    where <replaceable>size</replaceable> is a target file in
                    MiB. Use <option>--help</option> to see what the default
                    value is and then adjust accordingly.
                </para>
            </section>
            <section id="running.commandline.opencl">
                <title>Selecting OpenCL devices</title>
                <para>
                    By default, MLSGPU will run on all GPU devices it finds in
                    the system. This is often the desired result, but in some
                    cases it may be desirable to use extra devices or restrict
                    the set of devices used. In particular, when there are no
                    OpenCL-capable GPUs in the system, it will usually be
                    necessary to pass <option>--cl-cpu</option>.
                </para>
                <para>
                    There are three command-line options that control device
                    selection: <option>--cl-cpu</option>,
                    <option>--cl-gpu</option> and
                    <option>--cl-device</option>. The effects are additive,
                    i.e., any device that matches any of the command-line
                    selectors will be used. The <option>--cl-cpu</option> and
                    <option>--cl-gpu</option> options take no arguments, and
                    simple enable all CPU or GPU devices.
                </para>
                <para>
                    The <option>--cl-device</option> option can be used in two
                    ways: firstly,
                    <option>--cl-device=<replaceable>prefix</replaceable></option>
                    will enable all devices whose device name begins with
                    <replaceable>prefix</replaceable>. The device name is
                    determined by the OpenCL API; a tool like
                    <command>clinfo</command> from the AMD APP SDK is useful
                    to discover the names of the devices in the system.
                    Secondly,
                    <option>--cl-device=<replaceable>prefix</replaceable>:<replaceable>n</replaceable></option>
                    will enable just the <replaceable>n</replaceable>th device
                    (zero-based) whose name starts with
                    <replaceable>prefix</replaceable>.  This is mainly useful
                    if there are several identical devices in the system.
                </para>
                <para>
                    As an example, passing
                    <option>--cl-cpu</option>
                    <option>--cl-device=Intel</option>
                    <option>--cl-device=GeForce:0</option> will enable all CPU
                    devices, all devices whose name begins with
                    <literal>Intel</literal> and the first device whose name
                    begins with <literal>GeForce</literal>.
                </para>
                <warning>
                    <para>
                        When mixing devices that are not identical,
                        differences in floating-point computation can cause
                        variations at the join between blocks. This can lead
                        to cracks in the reconstructed mesh, and in extreme
                        cases the mesh may even become non-manifold. For final
                        production always use only identical devices.
                    </para>
                </warning>
                <para>
                    When MLSGPU starts, it will report which devices it is
                    using.
                </para>
            </section>
            <section id="running.commandline.smooth">
                <title>Smoothing</title>
                <para>
                    The MLS reconstruction is essentially a process to smooth
                    the noisy sampling process. The degree of smoothing can be
                    controlled with <option>--fit-smooth</option>. Increasing
                    the smoothing value will reduce noise, but may also smooth
                    out detail. As a side effect of the implementation,
                    increasing smoothing will also allow small holes to filled
                    in that would not have been filled at lower smoothing
                    levels. The running time scales roughly with the square of
                    the smoothing factor, so using too much smoothing can also
                    make MLSGPU very slow.
                </para>
            </section>
            <section id="running.commandline.prune">
                <title>Component pruning</title>
                <para>
                    The underlying reconstruction algorithm tends to create
                    spurious pieces of geometry that are disconnected from the
                    rest of the model, so as a final step any small connected
                    components are discarded. Usually this will just do the
                    right thing, but if the scans actually capture some small
                    feature that is disconnected from the rest of the scanned
                    data, it may accidentally be discarded. In this case, the
                    threshhold for discarding a component (as a fraction of
                    the total number of output vertices) may be specified with
                    <option>--fit-prune</option>.
                </para>
            </section>
            <section id="running.commandline.boundary">
                <title>Boundary handling</title>
                <para>
                    MLSGPU explicitly detects boundaries in the provided point
                    cloud. It tries to avoid extrapolating beyond these
                    boundaries, as these extrapolations tend to have very poor
                    quality. However, the heuristic is not perfect, and tends
                    to both cause unwanted small holes in the reconstruction
                    and to extrapolate in some areas it should not. The
                    default tries to balance the two, but the user can
                    override the threshhold using
                    <option>--fit-boundary-limit</option>. Increasing the
                    value will cause more extrapolation, while decreasing it
                    will reduce extrapolation but potentially open more holes.
                    It is also possible to completely disable the boundary
                    detection, and gain a little performance, by passing
                    <option>--fit-keep-boundary</option>.
                </para>
            </section>
            <section id="running.commandline.mesher">
                <title>Trading time against disk space</title>
                <para>
                    By default, MLSGPU will run only a single pass of
                    computation, and save the data it produces to temporary
                    storage before writing the output files. This is efficient
                    but requires disk space for temporary files that is
                    the same size as (actually slightly larger than) the final
                    output files (see <xref linkend="installation.stxxl"/>).
                    Passing <option>--mesher=big</option> selects an
                    alternative output strategy can be used which requires
                    about double the computation time but needs far less
                    temporary space. The exact amount of temporary space
                    required depends heavily on the order of points in the
                    input, but 10% of the size of the input should generally
                    be safe.
                </para>
            </section>
        </section>
        <section id="running.limitations">
            <title>Limitations</title>
            <para>
                There are a number of limitations to the amount and type of input and output
                that MLSGPU can handle:
            </para>
            <itemizedlist>
                <listitem><para>Only certain types of input files can be used.
                        See <xref linkend="running.input"/> for
                        details.</para></listitem>
                <listitem><para>Up to 16 million input files (although the OS will almost
                        certainly impose a lower limit, as the files are all
                        open at the same time)</para></listitem>
                <listitem><para>Up to 2<superscript>40</superscript> (about
                        1.1 trillion) points per input
                        file.</para></listitem>
                <listitem><para>The virtual address space must be sufficient
                        to hold all the input. This is only expected to be a
                        limitation on a 32-bit machine, where it will limit
                        the total size of the input files to around
                        2GiB.</para></listitem>
                <listitem><para>Up to 2<superscript>32</superscript> (about
                        four billion) vertices per output file (this is a
                        limitation of the PLY file
                        format).</para></listitem>
                <listitem><para>The total size of the model can be at most
                        2<superscript>20</superscript> (about one million)
                        times the grid spacing. For example, a model with a
                        side length of 1 kilometre cannot be reconstructed at
                        finer than 1mm.</para></listitem>
            </itemizedlist>
        </section>
    </chapter>
    <chapter id="troubleshooting">
        <title>Troubleshooting</title>
        <para>TODO</para>
        <!--
        Items to list:
        - configuration errors
        - meshlab crashes opening output files: remove comments
        - output not identical between runs: use bucket-threads=1
        - density error: check fit grid
        - no output files produced: check fit grid
        - lots of holes in output: use finer grid
        - some holes in output: use higher smoothing or less aggressive boundary handling
        - a disconnected component was deleted: use fit-prune
        - out of GPU memory: various options to decrease
        - out of CPU memory: reduce max-host-splats and bucket-threads
        -->
    </chapter>
</book>
